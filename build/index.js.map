{"version":3,"file":"index.js","sources":["../src/useTimeout.ts","../src/defaultTimeoutHandler.ts","../src/useTimeoutDefault.ts"],"sourcesContent":["import { useEffect, useRef } from 'react';\r\nimport { TimeoutHandler } from './TimeoutHandler';\r\n\r\nexport type CancelTimer = () => void;\r\nexport type UseTimeout = <T>(callback: () => void, timeout: number, timeHandler: TimeoutHandler<T>, deps?: unknown[]) => CancelTimer;\r\n\r\n/**\r\n * useTimeout is a React.js custom hook that sets a leak-safe timeout and returns\r\n * a function to cancel it before the timeout expires.\r\n * It's composed of two other native hooks, useRef and useEffect.\r\n * It requires a custom way of setting a timeout and clearing it, expressed as an implementation\r\n * of the generic TimeoutHandler<T> interface.\r\n * The timer is restarted every time an item in `deps` changes.\r\n * If a new callback is given to the hook before the previous timeout expires,\r\n * only the new callback will be executed at the moment the timeout expires.\r\n * When the hook receives a new callback, the timeout isn't reset.\r\n * \r\n * @param callback the function to be executed after the timeout expires\r\n * @param timeout the number of milliseconds after which the callback should be triggered\r\n * @param timeHandler TimeoutHandler instance that's used to set and clear the timeout\r\n * @param deps useEffect dependencies that should cause the timeout to be reset\r\n * @return function to cancel the timer before the timeout expires\r\n */\r\nexport const useTimeout: UseTimeout = (callback, timeout, timeHandler, deps = []) => {\r\n  const refCallback = useRef<() => void>();\r\n  const refTimer = useRef<(typeof timeHandler) extends TimeoutHandler<infer R> ? R : never | undefined>();\r\n\r\n  useEffect(() => {\r\n    refCallback.current = callback;\r\n  }, [callback]);\r\n\r\n  /**\r\n   * The timer is restarted every time an item in `deps` changes.\r\n   * \r\n   * TODO: The `react-hooks/exhaustive-deps` ESLint warning is disabled due to the fact that\r\n   * the linter isn't able to detect misused `useEffect` dependencies when given a computed\r\n   * array (such as `deps`). If possible, another solution that doesn't block the linter\r\n   * should be used.\r\n   */\r\n  useEffect(() => {\r\n    const timerID = timeHandler.setTimeout(refCallback.current!, timeout);\r\n    refTimer.current = timerID;\r\n\r\n    // cleans the timer identified by timerID when the effect is unmounted.\r\n    return () => timeHandler.clearTimeout(timerID);\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, deps);\r\n\r\n  /**\r\n   * Returns a function that can be used to cancel the current timeout.\r\n   * It does so using `timeHandler.clearTimeout` without exposing the last\r\n   * reference to the timer to the user.\r\n   */\r\n  function cancelTimer() {\r\n    return timeHandler.clearTimeout(refTimer.current);\r\n  }\r\n\r\n  return cancelTimer;\r\n}\r\n","import { TimeoutHandler } from './TimeoutHandler';\r\n\r\n/**\r\n * defaultTimeoutHandler implements the TimeoutHandler interface with the usual timer\r\n * functions available in browsers and in React Native, i.e. `setTimeout` and `clearTimeout`.\r\n */\r\nexport const defaultTimeoutHandler: TimeoutHandler<number> = {\r\n  setTimeout: (fn: () => void, timeout: number) => window.setTimeout(fn, timeout),\r\n  clearTimeout: (timeout: number | undefined) => { window.clearTimeout(timeout) },\r\n};\r\n","import { useTimeout, CancelTimer } from './useTimeout';\r\nimport { defaultTimeoutHandler } from './defaultTimeoutHandler';\r\n\r\nexport type UseTimeoutDefault = (callback: () => void, timeout: number, deps?: unknown[]) => CancelTimer;\r\n\r\n/**\r\n * useTimeoutDefault is a React.js custom hook that sets a leak-safe timeout and returns\r\n * a function to cancel it before the timeout expires.\r\n * It uses the default timeout handlers, i.e. window.setTimeout and window.clearTimeout.\r\n * It's composed of two other native hooks, useRef and useEffect.\r\n * If a new callback is given to the hook before the previous timeout expires,\r\n * only the new callback will be executed at the moment the timeout expires.\r\n * When the hook receives a new callback, the timeout isn't reset.\r\n * \r\n * @param callback the function to be executed after the timeout expires\r\n * @param timeout the number of milliseconds after which the callback should be triggered\r\n * @param deps useEffect dependencies that should cause the timeout to be reset\r\n * @return function to cancel the timer before the timeout expires\r\n */\r\nexport const useTimeoutDefault: UseTimeoutDefault = (callback, timeout, deps = []) => (\r\n  useTimeout(callback, timeout, defaultTimeoutHandler, deps)\r\n);\r\n"],"names":["useRef","useEffect"],"mappings":";;;;;;AAMA;;;;;;;;;;;;;;;;;IAiBa,UAAU,GAAe,UAAC,QAAQ,EAAE,OAAO,EAAE,WAAW,EAAE,IAAS;IAAT,qBAAA,EAAA,SAAS;IAC9E,IAAM,WAAW,GAAGA,YAAM,EAAc,CAAC;IACzC,IAAM,QAAQ,GAAGA,YAAM,EAAgF,CAAC;IAExGC,eAAS,CAAC;QACR,WAAW,CAAC,OAAO,GAAG,QAAQ,CAAC;KAChC,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;;;;;;;;;IAUfA,eAAS,CAAC;QACR,IAAM,OAAO,GAAG,WAAW,CAAC,UAAU,CAAC,WAAW,CAAC,OAAQ,EAAE,OAAO,CAAC,CAAC;QACtE,QAAQ,CAAC,OAAO,GAAG,OAAO,CAAC;;QAG3B,OAAO,cAAM,OAAA,WAAW,CAAC,YAAY,CAAC,OAAO,CAAC,GAAA,CAAC;;KAEhD,EAAE,IAAI,CAAC,CAAC;;;;;;IAOT,SAAS,WAAW;QAClB,OAAO,WAAW,CAAC,YAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;KACnD;IAED,OAAO,WAAW,CAAC;AACrB;;ACxDA;;;;AAIA,IAAa,qBAAqB,GAA2B;IAC3D,UAAU,EAAE,UAAC,EAAc,EAAE,OAAe,IAAK,OAAA,MAAM,CAAC,UAAU,CAAC,EAAE,EAAE,OAAO,CAAC,GAAA;IAC/E,YAAY,EAAE,UAAC,OAA2B,IAAO,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,CAAA,EAAE;CAChF;;ACJD;;;;;;;;;;;;;;AAcA,IAAa,iBAAiB,GAAsB,UAAC,QAAQ,EAAE,OAAO,EAAE,IAAS;IAAT,qBAAA,EAAA,SAAS;IAAK,QACpF,UAAU,CAAC,QAAQ,EAAE,OAAO,EAAE,qBAAqB,EAAE,IAAI,CAAC;AAD0B,CAErF;;;;;;"}